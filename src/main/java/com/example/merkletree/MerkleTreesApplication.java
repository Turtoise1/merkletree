package com.example.merkletree;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URL;
import java.security.SecureRandom;
import java.security.Security;
import java.util.ArrayList;
import java.util.List;

import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.cms.ContentInfo;
import org.bouncycastle.asn1.tsp.ArchiveTimeStamp;
import org.bouncycastle.asn1.tsp.PartialHashtree;
import org.bouncycastle.asn1.tsp.TimeStampReq;
import org.bouncycastle.asn1.tsp.TimeStampResp;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.crypto.util.AlgorithmIdentifierFactory;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.AlgorithmNameFinder;
import org.bouncycastle.operator.DefaultAlgorithmNameFinder;
import org.bouncycastle.tsp.TimeStampRequest;
import org.bouncycastle.tsp.TimeStampRequestGenerator;
import org.bouncycastle.tsp.TimeStampResponse;
import org.bouncycastle.tsp.TimeStampToken;
import org.bouncycastle.tsp.ers.ERSArchiveTimeStamp;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;

@SpringBootApplication
@Slf4j
public class MerkleTreesApplication {

    public static void main(String[] args) {
        SpringApplication.run(MerkleTreesApplication.class, args);
    }

    public static final String PROVIDER_NAME = "BC";

    @PostConstruct
    public void setupCrypto() {

        Security.addProvider(new BouncyCastleProvider());

        if (Security.getProvider(PROVIDER_NAME) == null) {
            log.error("Bouncy Castle provider is not installed");
        } else {
            log.info("Bouncy Castle provider is installed.");
        }

        Security.setProperty("crypto.policy", "unlimited");
    }

    /**
     * Taken from RFC 4998:
     * The lists of hash values of an Archive Timestamp can be generated by
     * building and reducing a Merkle hash tree.
     *
     * Such a hash tree can be built as follows:
     *
     * 1. Collect data objects to be timestamped.
     *
     * 2. Choose a secure hash algorithm H and generate hash values for the
     * data objects. These values will be the leaves of the hash tree.
     *
     * 3. For each data group containing more than one document, its
     * respective document hashes are binary sorted in ascending order,
     * concatenated, and hashed. The hash values are the complete
     * output from the hash algorithm, i.e., leading zeros are not
     * removed, with the most significant bit first.
     *
     * 4. If there is more than one hash value, place them in groups and
     * sort each group in binary ascending order. Concatenate these
     * values and generate new hash values, which are inner nodes of
     * this tree. (If additional hash values are needed, e.g., so that
     * all nodes have the same number of children, any data may be
     * hashed using H and used.) Repeat this step until there is only
     * one hash value, which is the root node of the hash tree.
     *
     * 5. Obtain a timestamp for this root hash value. The hash algorithm
     * in the timestamp request MUST be the same as the hash algorithm
     * of the hash tree, or the digestAlgorithm field of the
     * ArchiveTimeStamp MUST be present and specify the hash algorithm
     * of the hash tree.
     */
    public ArchiveTimeStamp createArchiveTimestamp(TestComposite testComposite, HashAlgorithm hashAlgorithm) {
        // Generate hash values
        MerkleTreeNode tree = new MerkleTreeNode(testComposite, hashAlgorithm);
        byte[] rootHash = tree.getHash();

        // Obtain a timestamp for the root hash value
        TimeStampRequestGenerator generator = new TimeStampRequestGenerator();
        TimeStampRequest request = generator.generate(hashAlgorithm.getOID(), rootHash);
        ContentInfo timeStamp = requestTimeStamp(request).toCMSSignedData().toASN1Structure();

        PartialHashtree[] reducedHashTree = tree.getPartial();

        SecureRandom secureRandom = new SecureRandom();
        int keySize = 256; // -1 if unknown
        AlgorithmIdentifier identifier = AlgorithmIdentifierFactory.generateEncryptionAlgID(hashAlgorithm.getOID(),
                keySize, secureRandom);

        // Create the archive timestamp
        ArchiveTimeStamp archiveTimeStamp = new ArchiveTimeStamp(identifier, reducedHashTree, timeStamp);
        return archiveTimeStamp;
    }

    /**
     * Taken from
     * https://www.javatips.net/api/jsign-master/jsign-core/src/main/java/net/jsign/timestamp/RFC3161Timestamper.java
     *
     * @param request
     * @return
     * @throws IOException
     */
    private TimeStampToken requestTimeStamp(TimeStampRequest request) throws IOException {
        byte encodedRequest[] = request.getEncoded();
        URL tsaurl = URI.create("https://zeitstempel.dfn.de/").toURL();

        HttpURLConnection conn = (HttpURLConnection) tsaurl.openConnection();
        conn.setConnectTimeout(10000);
        conn.setReadTimeout(10000);
        conn.setDoOutput(true);
        conn.setDoInput(true);
        conn.setUseCaches(false);
        conn.setRequestMethod("POST");
        conn.setRequestProperty("Content-type", "application/timestamp-query");
        conn.setRequestProperty("Content-length", String.valueOf(encodedRequest.length));
        conn.setRequestProperty("Accept", "application/timestamp-reply");
        conn.setRequestProperty("User-Agent", "Transport");

        conn.getOutputStream().write(encodedRequest);
        conn.getOutputStream().flush();

        if (conn.getResponseCode() >= 400) {
            throw new IOException("Unable to complete the timestamping due to HTTP error: " + conn.getResponseCode()
                    + " - " + conn.getResponseMessage());
        }

        try (ASN1InputStream inputStream = new ASN1InputStream(conn.getInputStream())) {

            TimeStampResp resp = TimeStampResp.getInstance(inputStream.readObject());
            TimeStampResponse response = new TimeStampResponse(resp);
            response.validate(request);
            if (response.getStatus() != 0) {
                throw new IOException("Unable to complete the timestamping due to an invalid response ("
                        + response.getStatusString() + ")");
            }

            return response.getTimeStampToken();

        } catch (Exception e) {
            throw new RuntimeException("Unable to complete the timestamping", e);
        }
    }

}

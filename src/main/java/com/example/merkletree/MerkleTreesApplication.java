package com.example.merkletree;

import java.security.Security;
import java.util.ArrayList;
import java.util.List;

import org.bouncycastle.asn1.cms.ContentInfo;
import org.bouncycastle.asn1.tsp.ArchiveTimeStamp;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;

@SpringBootApplication
@Slf4j
public class MerkleTreesApplication {

    public static void main(String[] args) {
        SpringApplication.run(MerkleTreesApplication.class, args);
    }

    public static final String PROVIDER_NAME = "BC";

    @PostConstruct
    public void setupCrypto() {

        Security.addProvider(new BouncyCastleProvider());

        if (Security.getProvider(PROVIDER_NAME) == null) {
            log.error("Bouncy Castle provider is not installed");
        } else {
            log.info("Bouncy Castle provider is installed.");
        }

        Security.setProperty("crypto.policy", "unlimited");
    }

    /**
     * Taken from RFC 4998:
     * The lists of hash values of an Archive Timestamp can be generated by
     * building and reducing a Merkle hash tree.
     *
     * Such a hash tree can be built as follows:
     *
     * 1. Collect data objects to be timestamped.
     *
     * 2. Choose a secure hash algorithm H and generate hash values for the
     * data objects. These values will be the leaves of the hash tree.
     *
     * 3. For each data group containing more than one document, its
     * respective document hashes are binary sorted in ascending order,
     * concatenated, and hashed. The hash values are the complete
     * output from the hash algorithm, i.e., leading zeros are not
     * removed, with the most significant bit first.
     *
     * 4. If there is more than one hash value, place them in groups and
     * sort each group in binary ascending order. Concatenate these
     * values and generate new hash values, which are inner nodes of
     * this tree. (If additional hash values are needed, e.g., so that
     * all nodes have the same number of children, any data may be
     * hashed using H and used.) Repeat this step until there is only
     * one hash value, which is the root node of the hash tree.
     *
     * 5. Obtain a timestamp for this root hash value. The hash algorithm
     * in the timestamp request MUST be the same as the hash algorithm
     * of the hash tree, or the digestAlgorithm field of the
     * ArchiveTimeStamp MUST be present and specify the hash algorithm
     * of the hash tree.
     */
    public ArchiveTimeStamp createArchiveTimestamp(TestComposite testComposite) {
        // Generate hash values
        MerkleTreeNode tree = new MerkleTreeNode(testComposite, HashAlgorithm.SHA256);
        byte[] rootHash = tree.getHash();

        // Obtain a timestamp for the root hash value
        ContentInfo timeStamp = new ContentInfo(contentType, content);

        // Create the archive timestamp
        ArchiveTimeStamp archiveTimeStamp = new ArchiveTimeStamp(digestAlgorithm, reducedHashTree, timeStamp);
        return archiveTimeStamp;
    }
}
